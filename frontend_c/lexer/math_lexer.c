// Auto-generated by lexer_generator.py
#include <stdio.h>
#include <token.h>
#include <token_values.h>
#include "math_lexer.h"
#include <math_tokens.h>


Token get_next_token(char first_char, char second_char){
    char *curr_char;
    char *lookahead;
    strcpy(curr_char, first_char);
    strcpy(lookahead, second_char);

    if (is_blank(curr_char))
        return skip_blanks();

    if (isalpha(curr_char))
        return get_word();

    // Backslash tokens
    if (strcmp(curr_char, "\\"))
        switch (hash(lookahead)){
            case BACKLASH:
                return new_m_newline_token();
            case RPAR:
                return new_m_stop_inl_math_token();
            case RSQB:
                return new_m_stop_dsp_math_token();
            case LBRACE:
                return new_m_lset_brace_token();
            case RBRACE:
                return new_m_rset_brace_token();
       }
    // Two character tokens
    if (strcmp(curr_char, "$") && strcmp(lookahead, "$")
        return new_m_stop_dbl_dollar_token();
    if (strcmp(curr_char, "_") && strcmp(lookahead, "{")
        return new_m_lsub_grp_token();
    if (strcmp(curr_char, "^") && strcmp(lookahead, "{")
        return new_m_lsup_grp_token();

    // Single character tokens
    switch(hash(curr_char)){   
        case UNDERSCORE:
            return new_m_sub_token();
        case CARET:
            return new_m_sup_token();
        case AMPER:
            return new_m_align_token();
        case LPAR:
            return new_m_lpar_token();
        case RPAR:
            return new_m_rpar_token();
        case LSQB:
            return new_m_lsqb_token();
        case RSQB:
            return new_m_rsqb_token();
        case LBRACE:
            return new_m_lbrace_token();
        case RBRACE:
            return new_m_rbrace_token();
        case DOLLAR:
            return new_m_stop_dollar_token();
        case RBRACE:
            return new_m_rsub_grp_token();
        case RBRACE:
            return new_m_rsup_grp_token();
   }
}


